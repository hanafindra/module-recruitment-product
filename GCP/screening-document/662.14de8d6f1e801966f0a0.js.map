{"version":3,"file":"662.14de8d6f1e801966f0a0.js","mappings":"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","sources":["webpack://screening_document/../../../../node_modules/react-resizable-panels/dist/react-resizable-panels.browser.esm.js"],"sourcesContent":["import * as React from 'react';\n\n// This module exists to work around Webpack issue https://github.com/webpack/webpack/issues/14814\n\n// eslint-disable-next-line no-restricted-imports\n\nconst {\n  createElement,\n  createContext,\n  createRef,\n  forwardRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  useState\n} = React;\n\n// `Math.random()` and `.slice(0, 5)` prevents bundlers from trying to `import { useId } from 'react'`\nconst useId = React[`useId${Math.random()}`.slice(0, 5)];\nconst useLayoutEffect_do_not_use_directly = useLayoutEffect;\n\n// The \"contextmenu\" event is not supported as a PointerEvent in all browsers yet, so MouseEvent still need to be handled\n\nconst PanelGroupContext = createContext(null);\nPanelGroupContext.displayName = \"PanelGroupContext\";\n\nconst useIsomorphicLayoutEffect = useLayoutEffect_do_not_use_directly ;\n\nconst wrappedUseId = typeof useId === \"function\" ? useId : () => null;\nlet counter = 0;\nfunction useUniqueId(idFromParams = null) {\n  const idFromUseId = wrappedUseId();\n  const idRef = useRef(idFromParams || idFromUseId || null);\n  if (idRef.current === null) {\n    idRef.current = \"\" + counter++;\n  }\n  return idFromParams !== null && idFromParams !== void 0 ? idFromParams : idRef.current;\n}\n\nfunction PanelWithForwardedRef({\n  children,\n  className: classNameFromProps = \"\",\n  collapsedSize,\n  collapsible,\n  defaultSize,\n  forwardedRef,\n  id: idFromProps,\n  maxSize,\n  minSize,\n  onCollapse,\n  onExpand,\n  onResize,\n  order,\n  style: styleFromProps,\n  tagName: Type = \"div\",\n  ...rest\n}) {\n  const context = useContext(PanelGroupContext);\n  if (context === null) {\n    throw Error(`Panel components must be rendered within a PanelGroup container`);\n  }\n  const {\n    collapsePanel,\n    expandPanel,\n    getPanelSize,\n    getPanelStyle,\n    groupId,\n    isPanelCollapsed,\n    reevaluatePanelConstraints,\n    registerPanel,\n    resizePanel,\n    unregisterPanel\n  } = context;\n  const panelId = useUniqueId(idFromProps);\n  const panelDataRef = useRef({\n    callbacks: {\n      onCollapse,\n      onExpand,\n      onResize\n    },\n    constraints: {\n      collapsedSize,\n      collapsible,\n      defaultSize,\n      maxSize,\n      minSize\n    },\n    id: panelId,\n    idIsFromProps: idFromProps !== undefined,\n    order\n  });\n  useRef({\n    didLogMissingDefaultSizeWarning: false\n  });\n  useIsomorphicLayoutEffect(() => {\n    const {\n      callbacks,\n      constraints\n    } = panelDataRef.current;\n    const prevConstraints = {\n      ...constraints\n    };\n    panelDataRef.current.id = panelId;\n    panelDataRef.current.idIsFromProps = idFromProps !== undefined;\n    panelDataRef.current.order = order;\n    callbacks.onCollapse = onCollapse;\n    callbacks.onExpand = onExpand;\n    callbacks.onResize = onResize;\n    constraints.collapsedSize = collapsedSize;\n    constraints.collapsible = collapsible;\n    constraints.defaultSize = defaultSize;\n    constraints.maxSize = maxSize;\n    constraints.minSize = minSize;\n\n    // If constraints have changed, we should revisit panel sizes.\n    // This is uncommon but may happen if people are trying to implement pixel based constraints.\n    if (prevConstraints.collapsedSize !== constraints.collapsedSize || prevConstraints.collapsible !== constraints.collapsible || prevConstraints.maxSize !== constraints.maxSize || prevConstraints.minSize !== constraints.minSize) {\n      reevaluatePanelConstraints(panelDataRef.current, prevConstraints);\n    }\n  });\n  useIsomorphicLayoutEffect(() => {\n    const panelData = panelDataRef.current;\n    registerPanel(panelData);\n    return () => {\n      unregisterPanel(panelData);\n    };\n  }, [order, panelId, registerPanel, unregisterPanel]);\n  useImperativeHandle(forwardedRef, () => ({\n    collapse: () => {\n      collapsePanel(panelDataRef.current);\n    },\n    expand: minSize => {\n      expandPanel(panelDataRef.current, minSize);\n    },\n    getId() {\n      return panelId;\n    },\n    getSize() {\n      return getPanelSize(panelDataRef.current);\n    },\n    isCollapsed() {\n      return isPanelCollapsed(panelDataRef.current);\n    },\n    isExpanded() {\n      return !isPanelCollapsed(panelDataRef.current);\n    },\n    resize: size => {\n      resizePanel(panelDataRef.current, size);\n    }\n  }), [collapsePanel, expandPanel, getPanelSize, isPanelCollapsed, panelId, resizePanel]);\n  const style = getPanelStyle(panelDataRef.current, defaultSize);\n  return createElement(Type, {\n    ...rest,\n    children,\n    className: classNameFromProps,\n    id: idFromProps,\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    // CSS selectors\n    \"data-panel\": \"\",\n    \"data-panel-collapsible\": collapsible || undefined,\n    \"data-panel-group-id\": groupId,\n    \"data-panel-id\": panelId,\n    \"data-panel-size\": parseFloat(\"\" + style.flexGrow).toFixed(1)\n  });\n}\nconst Panel = forwardRef((props, ref) => createElement(PanelWithForwardedRef, {\n  ...props,\n  forwardedRef: ref\n}));\nPanelWithForwardedRef.displayName = \"Panel\";\nPanel.displayName = \"forwardRef(Panel)\";\n\nlet nonce;\nfunction getNonce() {\n  return nonce;\n}\nfunction setNonce(value) {\n  nonce = value;\n}\n\nlet currentCursorStyle = null;\nlet enabled = true;\nlet styleElement = null;\nfunction disableGlobalCursorStyles() {\n  enabled = false;\n}\nfunction enableGlobalCursorStyles() {\n  enabled = true;\n}\nfunction getCursorStyle(state, constraintFlags) {\n  if (constraintFlags) {\n    const horizontalMin = (constraintFlags & EXCEEDED_HORIZONTAL_MIN) !== 0;\n    const horizontalMax = (constraintFlags & EXCEEDED_HORIZONTAL_MAX) !== 0;\n    const verticalMin = (constraintFlags & EXCEEDED_VERTICAL_MIN) !== 0;\n    const verticalMax = (constraintFlags & EXCEEDED_VERTICAL_MAX) !== 0;\n    if (horizontalMin) {\n      if (verticalMin) {\n        return \"se-resize\";\n      } else if (verticalMax) {\n        return \"ne-resize\";\n      } else {\n        return \"e-resize\";\n      }\n    } else if (horizontalMax) {\n      if (verticalMin) {\n        return \"sw-resize\";\n      } else if (verticalMax) {\n        return \"nw-resize\";\n      } else {\n        return \"w-resize\";\n      }\n    } else if (verticalMin) {\n      return \"s-resize\";\n    } else if (verticalMax) {\n      return \"n-resize\";\n    }\n  }\n  switch (state) {\n    case \"horizontal\":\n      return \"ew-resize\";\n    case \"intersection\":\n      return \"move\";\n    case \"vertical\":\n      return \"ns-resize\";\n  }\n}\nfunction resetGlobalCursorStyle() {\n  if (styleElement !== null) {\n    document.head.removeChild(styleElement);\n    currentCursorStyle = null;\n    styleElement = null;\n  }\n}\nfunction setGlobalCursorStyle(state, constraintFlags) {\n  if (!enabled) {\n    return;\n  }\n  const style = getCursorStyle(state, constraintFlags);\n  if (currentCursorStyle === style) {\n    return;\n  }\n  currentCursorStyle = style;\n  if (styleElement === null) {\n    styleElement = document.createElement(\"style\");\n    const nonce = getNonce();\n    if (nonce) {\n      styleElement.setAttribute(\"nonce\", nonce);\n    }\n    document.head.appendChild(styleElement);\n  }\n  styleElement.innerHTML = `*{cursor: ${style}!important;}`;\n}\n\nfunction isKeyDown(event) {\n  return event.type === \"keydown\";\n}\nfunction isPointerEvent(event) {\n  return event.type.startsWith(\"pointer\");\n}\nfunction isMouseEvent(event) {\n  return event.type.startsWith(\"mouse\");\n}\n\nfunction getResizeEventCoordinates(event) {\n  if (isPointerEvent(event)) {\n    if (event.isPrimary) {\n      return {\n        x: event.clientX,\n        y: event.clientY\n      };\n    }\n  } else if (isMouseEvent(event)) {\n    return {\n      x: event.clientX,\n      y: event.clientY\n    };\n  }\n  return {\n    x: Infinity,\n    y: Infinity\n  };\n}\n\nfunction getInputType() {\n  if (typeof matchMedia === \"function\") {\n    return matchMedia(\"(pointer:coarse)\").matches ? \"coarse\" : \"fine\";\n  }\n}\n\nfunction intersects(rectOne, rectTwo, strict) {\n  if (strict) {\n    return rectOne.x < rectTwo.x + rectTwo.width && rectOne.x + rectOne.width > rectTwo.x && rectOne.y < rectTwo.y + rectTwo.height && rectOne.y + rectOne.height > rectTwo.y;\n  } else {\n    return rectOne.x <= rectTwo.x + rectTwo.width && rectOne.x + rectOne.width >= rectTwo.x && rectOne.y <= rectTwo.y + rectTwo.height && rectOne.y + rectOne.height >= rectTwo.y;\n  }\n}\n\n// Forked from NPM stacking-order@2.0.0\n\n/**\n * Determine which of two nodes appears in front of the other â€”\n * if `a` is in front, returns 1, otherwise returns -1\n * @param {HTMLElement} a\n * @param {HTMLElement} b\n */\nfunction compare(a, b) {\n  if (a === b) throw new Error(\"Cannot compare node with itself\");\n  const ancestors = {\n    a: get_ancestors(a),\n    b: get_ancestors(b)\n  };\n  let common_ancestor;\n\n  // remove shared ancestors\n  while (ancestors.a.at(-1) === ancestors.b.at(-1)) {\n    a = ancestors.a.pop();\n    b = ancestors.b.pop();\n    common_ancestor = a;\n  }\n  assert(common_ancestor, \"Stacking order can only be calculated for elements with a common ancestor\");\n  const z_indexes = {\n    a: get_z_index(find_stacking_context(ancestors.a)),\n    b: get_z_index(find_stacking_context(ancestors.b))\n  };\n  if (z_indexes.a === z_indexes.b) {\n    const children = common_ancestor.childNodes;\n    const furthest_ancestors = {\n      a: ancestors.a.at(-1),\n      b: ancestors.b.at(-1)\n    };\n    let i = children.length;\n    while (i--) {\n      const child = children[i];\n      if (child === furthest_ancestors.a) return 1;\n      if (child === furthest_ancestors.b) return -1;\n    }\n  }\n  return Math.sign(z_indexes.a - z_indexes.b);\n}\nconst props = /\\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\\b/;\n\n/** @param {HTMLElement} node */\nfunction is_flex_item(node) {\n  var _get_parent;\n  // @ts-ignore\n  const display = getComputedStyle((_get_parent = get_parent(node)) !== null && _get_parent !== void 0 ? _get_parent : node).display;\n  return display === \"flex\" || display === \"inline-flex\";\n}\n\n/** @param {HTMLElement} node */\nfunction creates_stacking_context(node) {\n  const style = getComputedStyle(node);\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\n  if (style.position === \"fixed\") return true;\n  // Forked to fix upstream bug https://github.com/Rich-Harris/stacking-order/issues/3\n  // if (\n  //   (style.zIndex !== \"auto\" && style.position !== \"static\") ||\n  //   is_flex_item(node)\n  // )\n  if (style.zIndex !== \"auto\" && (style.position !== \"static\" || is_flex_item(node))) return true;\n  if (+style.opacity < 1) return true;\n  if (\"transform\" in style && style.transform !== \"none\") return true;\n  if (\"webkitTransform\" in style && style.webkitTransform !== \"none\") return true;\n  if (\"mixBlendMode\" in style && style.mixBlendMode !== \"normal\") return true;\n  if (\"filter\" in style && style.filter !== \"none\") return true;\n  if (\"webkitFilter\" in style && style.webkitFilter !== \"none\") return true;\n  if (\"isolation\" in style && style.isolation === \"isolate\") return true;\n  if (props.test(style.willChange)) return true;\n  // @ts-expect-error\n  if (style.webkitOverflowScrolling === \"touch\") return true;\n  return false;\n}\n\n/** @param {HTMLElement[]} nodes */\nfunction find_stacking_context(nodes) {\n  let i = nodes.length;\n  while (i--) {\n    const node = nodes[i];\n    assert(node, \"Missing node\");\n    if (creates_stacking_context(node)) return node;\n  }\n  return null;\n}\n\n/** @param {HTMLElement} node */\nfunction get_z_index(node) {\n  return node && Number(getComputedStyle(node).zIndex) || 0;\n}\n\n/** @param {HTMLElement} node */\nfunction get_ancestors(node) {\n  const ancestors = [];\n  while (node) {\n    ancestors.push(node);\n    // @ts-ignore\n    node = get_parent(node);\n  }\n  return ancestors; // [ node, ... <body>, <html>, document ]\n}\n\n/** @param {HTMLElement} node */\nfunction get_parent(node) {\n  const {\n    parentNode\n  } = node;\n  if (parentNode && parentNode instanceof ShadowRoot) {\n    return parentNode.host;\n  }\n  return parentNode;\n}\n\nconst EXCEEDED_HORIZONTAL_MIN = 0b0001;\nconst EXCEEDED_HORIZONTAL_MAX = 0b0010;\nconst EXCEEDED_VERTICAL_MIN = 0b0100;\nconst EXCEEDED_VERTICAL_MAX = 0b1000;\nconst isCoarsePointer = getInputType() === \"coarse\";\nlet intersectingHandles = [];\nlet isPointerDown = false;\nlet ownerDocumentCounts = new Map();\nlet panelConstraintFlags = new Map();\nconst registeredResizeHandlers = new Set();\nfunction registerResizeHandle(resizeHandleId, element, direction, hitAreaMargins, setResizeHandlerState) {\n  var _ownerDocumentCounts$;\n  const {\n    ownerDocument\n  } = element;\n  const data = {\n    direction,\n    element,\n    hitAreaMargins,\n    setResizeHandlerState\n  };\n  const count = (_ownerDocumentCounts$ = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$ !== void 0 ? _ownerDocumentCounts$ : 0;\n  ownerDocumentCounts.set(ownerDocument, count + 1);\n  registeredResizeHandlers.add(data);\n  updateListeners();\n  return function unregisterResizeHandle() {\n    var _ownerDocumentCounts$2;\n    panelConstraintFlags.delete(resizeHandleId);\n    registeredResizeHandlers.delete(data);\n    const count = (_ownerDocumentCounts$2 = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$2 !== void 0 ? _ownerDocumentCounts$2 : 1;\n    ownerDocumentCounts.set(ownerDocument, count - 1);\n    updateListeners();\n    if (count === 1) {\n      ownerDocumentCounts.delete(ownerDocument);\n    }\n\n    // If the resize handle that is currently unmounting is intersecting with the pointer,\n    // update the global pointer to account for the change\n    if (intersectingHandles.includes(data)) {\n      const index = intersectingHandles.indexOf(data);\n      if (index >= 0) {\n        intersectingHandles.splice(index, 1);\n      }\n      updateCursor();\n    }\n  };\n}\nfunction handlePointerDown(event) {\n  const {\n    target\n  } = event;\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n  isPointerDown = true;\n  recalculateIntersectingHandles({\n    target,\n    x,\n    y\n  });\n  updateListeners();\n  if (intersectingHandles.length > 0) {\n    updateResizeHandlerStates(\"down\", event);\n    event.preventDefault();\n    event.stopPropagation();\n  }\n}\nfunction handlePointerMove(event) {\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n\n  // Edge case (see #340)\n  // Detect when the pointer has been released outside an iframe on a different domain\n  if (isPointerDown && event.buttons === 0) {\n    isPointerDown = false;\n    updateResizeHandlerStates(\"up\", event);\n  }\n  if (!isPointerDown) {\n    const {\n      target\n    } = event;\n\n    // Recalculate intersecting handles whenever the pointer moves, except if it has already been pressed\n    // at that point, the handles may not move with the pointer (depending on constraints)\n    // but the same set of active handles should be locked until the pointer is released\n    recalculateIntersectingHandles({\n      target,\n      x,\n      y\n    });\n  }\n  updateResizeHandlerStates(\"move\", event);\n\n  // Update cursor based on return value(s) from active handles\n  updateCursor();\n  if (intersectingHandles.length > 0) {\n    event.preventDefault();\n  }\n}\nfunction handlePointerUp(event) {\n  const {\n    target\n  } = event;\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n  panelConstraintFlags.clear();\n  isPointerDown = false;\n  if (intersectingHandles.length > 0) {\n    event.preventDefault();\n  }\n  updateResizeHandlerStates(\"up\", event);\n  recalculateIntersectingHandles({\n    target,\n    x,\n    y\n  });\n  updateCursor();\n  updateListeners();\n}\nfunction recalculateIntersectingHandles({\n  target,\n  x,\n  y\n}) {\n  intersectingHandles.splice(0);\n  let targetElement = null;\n  if (target instanceof HTMLElement) {\n    targetElement = target;\n  }\n  registeredResizeHandlers.forEach(data => {\n    const {\n      element: dragHandleElement,\n      hitAreaMargins\n    } = data;\n    const dragHandleRect = dragHandleElement.getBoundingClientRect();\n    const {\n      bottom,\n      left,\n      right,\n      top\n    } = dragHandleRect;\n    const margin = isCoarsePointer ? hitAreaMargins.coarse : hitAreaMargins.fine;\n    const eventIntersects = x >= left - margin && x <= right + margin && y >= top - margin && y <= bottom + margin;\n    if (eventIntersects) {\n      // TRICKY\n      // We listen for pointers events at the root in order to support hit area margins\n      // (determining when the pointer is close enough to an element to be considered a \"hit\")\n      // Clicking on an element \"above\" a handle (e.g. a modal) should prevent a hit though\n      // so at this point we need to compare stacking order of a potentially intersecting drag handle,\n      // and the element that was actually clicked/touched\n      if (targetElement !== null && dragHandleElement !== targetElement && !dragHandleElement.contains(targetElement) && !targetElement.contains(dragHandleElement) &&\n      // Calculating stacking order has a cost, so we should avoid it if possible\n      // That is why we only check potentially intersecting handles,\n      // and why we skip if the event target is within the handle's DOM\n      compare(targetElement, dragHandleElement) > 0) {\n        // If the target is above the drag handle, then we also need to confirm they overlap\n        // If they are beside each other (e.g. a panel and its drag handle) then the handle is still interactive\n        //\n        // It's not enough to compare only the target\n        // The target might be a small element inside of a larger container\n        // (For example, a SPAN or a DIV inside of a larger modal dialog)\n        let currentElement = targetElement;\n        let didIntersect = false;\n        while (currentElement) {\n          if (currentElement.contains(dragHandleElement)) {\n            break;\n          } else if (intersects(currentElement.getBoundingClientRect(), dragHandleRect, true)) {\n            didIntersect = true;\n            break;\n          }\n          currentElement = currentElement.parentElement;\n        }\n        if (didIntersect) {\n          return;\n        }\n      }\n      intersectingHandles.push(data);\n    }\n  });\n}\nfunction reportConstraintsViolation(resizeHandleId, flag) {\n  panelConstraintFlags.set(resizeHandleId, flag);\n}\nfunction updateCursor() {\n  let intersectsHorizontal = false;\n  let intersectsVertical = false;\n  intersectingHandles.forEach(data => {\n    const {\n      direction\n    } = data;\n    if (direction === \"horizontal\") {\n      intersectsHorizontal = true;\n    } else {\n      intersectsVertical = true;\n    }\n  });\n  let constraintFlags = 0;\n  panelConstraintFlags.forEach(flag => {\n    constraintFlags |= flag;\n  });\n  if (intersectsHorizontal && intersectsVertical) {\n    setGlobalCursorStyle(\"intersection\", constraintFlags);\n  } else if (intersectsHorizontal) {\n    setGlobalCursorStyle(\"horizontal\", constraintFlags);\n  } else if (intersectsVertical) {\n    setGlobalCursorStyle(\"vertical\", constraintFlags);\n  } else {\n    resetGlobalCursorStyle();\n  }\n}\nfunction updateListeners() {\n  ownerDocumentCounts.forEach((_, ownerDocument) => {\n    const {\n      body\n    } = ownerDocument;\n    body.removeEventListener(\"contextmenu\", handlePointerUp);\n    body.removeEventListener(\"pointerdown\", handlePointerDown);\n    body.removeEventListener(\"pointerleave\", handlePointerMove);\n    body.removeEventListener(\"pointermove\", handlePointerMove);\n  });\n  window.removeEventListener(\"pointerup\", handlePointerUp);\n  window.removeEventListener(\"pointercancel\", handlePointerUp);\n  if (registeredResizeHandlers.size > 0) {\n    if (isPointerDown) {\n      if (intersectingHandles.length > 0) {\n        ownerDocumentCounts.forEach((count, ownerDocument) => {\n          const {\n            body\n          } = ownerDocument;\n          if (count > 0) {\n            body.addEventListener(\"contextmenu\", handlePointerUp);\n            body.addEventListener(\"pointerleave\", handlePointerMove);\n            body.addEventListener(\"pointermove\", handlePointerMove);\n          }\n        });\n      }\n      window.addEventListener(\"pointerup\", handlePointerUp);\n      window.addEventListener(\"pointercancel\", handlePointerUp);\n    } else {\n      ownerDocumentCounts.forEach((count, ownerDocument) => {\n        const {\n          body\n        } = ownerDocument;\n        if (count > 0) {\n          body.addEventListener(\"pointerdown\", handlePointerDown, {\n            capture: true\n          });\n          body.addEventListener(\"pointermove\", handlePointerMove);\n        }\n      });\n    }\n  }\n}\nfunction updateResizeHandlerStates(action, event) {\n  registeredResizeHandlers.forEach(data => {\n    const {\n      setResizeHandlerState\n    } = data;\n    const isActive = intersectingHandles.includes(data);\n    setResizeHandlerState(action, isActive, event);\n  });\n}\n\nfunction useForceUpdate() {\n  const [_, setCount] = useState(0);\n  return useCallback(() => setCount(prevCount => prevCount + 1), []);\n}\n\nfunction assert(expectedCondition, message) {\n  if (!expectedCondition) {\n    console.error(message);\n    throw Error(message);\n  }\n}\n\nconst PRECISION = 10;\n\nfunction fuzzyCompareNumbers(actual, expected, fractionDigits = PRECISION) {\n  if (actual.toFixed(fractionDigits) === expected.toFixed(fractionDigits)) {\n    return 0;\n  } else {\n    return actual > expected ? 1 : -1;\n  }\n}\nfunction fuzzyNumbersEqual$1(actual, expected, fractionDigits = PRECISION) {\n  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;\n}\n\nfunction fuzzyNumbersEqual(actual, expected, fractionDigits) {\n  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;\n}\n\nfunction fuzzyLayoutsEqual(actual, expected, fractionDigits) {\n  if (actual.length !== expected.length) {\n    return false;\n  }\n  for (let index = 0; index < actual.length; index++) {\n    const actualSize = actual[index];\n    const expectedSize = expected[index];\n    if (!fuzzyNumbersEqual(actualSize, expectedSize, fractionDigits)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Panel size must be in percentages; pixel values should be pre-converted\nfunction resizePanel({\n  panelConstraints: panelConstraintsArray,\n  panelIndex,\n  size\n}) {\n  const panelConstraints = panelConstraintsArray[panelIndex];\n  assert(panelConstraints != null, `Panel constraints not found for index ${panelIndex}`);\n  let {\n    collapsedSize = 0,\n    collapsible,\n    maxSize = 100,\n    minSize = 0\n  } = panelConstraints;\n  if (fuzzyCompareNumbers(size, minSize) < 0) {\n    if (collapsible) {\n      // Collapsible panels should snap closed or open only once they cross the halfway point between collapsed and min size.\n      const halfwayPoint = (collapsedSize + minSize) / 2;\n      if (fuzzyCompareNumbers(size, halfwayPoint) < 0) {\n        size = collapsedSize;\n      } else {\n        size = minSize;\n      }\n    } else {\n      size = minSize;\n    }\n  }\n  size = Math.min(maxSize, size);\n  size = parseFloat(size.toFixed(PRECISION));\n  return size;\n}\n\n// All units must be in percentages; pixel values should be pre-converted\nfunction adjustLayoutByDelta({\n  delta,\n  initialLayout,\n  panelConstraints: panelConstraintsArray,\n  pivotIndices,\n  prevLayout,\n  trigger\n}) {\n  if (fuzzyNumbersEqual(delta, 0)) {\n    return initialLayout;\n  }\n  const nextLayout = [...initialLayout];\n  const [firstPivotIndex, secondPivotIndex] = pivotIndices;\n  assert(firstPivotIndex != null, \"Invalid first pivot index\");\n  assert(secondPivotIndex != null, \"Invalid second pivot index\");\n  let deltaApplied = 0;\n\n  // const DEBUG = [];\n  // DEBUG.push(`adjustLayoutByDelta()`);\n  // DEBUG.push(`  initialLayout: ${initialLayout.join(\", \")}`);\n  // DEBUG.push(`  prevLayout: ${prevLayout.join(\", \")}`);\n  // DEBUG.push(`  delta: ${delta}`);\n  // DEBUG.push(`  pivotIndices: ${pivotIndices.join(\", \")}`);\n  // DEBUG.push(`  trigger: ${trigger}`);\n  // DEBUG.push(\"\");\n\n  // A resizing panel affects the panels before or after it.\n  //\n  // A negative delta means the panel(s) immediately after the resize handle should grow/expand by decreasing its offset.\n  // Other panels may also need to shrink/contract (and shift) to make room, depending on the min weights.\n  //\n  // A positive delta means the panel(s) immediately before the resize handle should \"expand\".\n  // This is accomplished by shrinking/contracting (and shifting) one or more of the panels after the resize handle.\n\n  {\n    // If this is a resize triggered by a keyboard event, our logic for expanding/collapsing is different.\n    // We no longer check the halfway threshold because this may prevent the panel from expanding at all.\n    if (trigger === \"keyboard\") {\n      {\n        // Check if we should expand a collapsed panel\n        const index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        const panelConstraints = panelConstraintsArray[index];\n        assert(panelConstraints, `Panel constraints not found for index ${index}`);\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panelConstraints;\n\n        // DEBUG.push(`edge case check 1: ${index}`);\n        // DEBUG.push(`  -> collapsible? ${collapsible}`);\n        if (collapsible) {\n          const prevSize = initialLayout[index];\n          assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n          if (fuzzyNumbersEqual(prevSize, collapsedSize)) {\n            const localDelta = minSize - prevSize;\n            // DEBUG.push(`  -> expand delta: ${localDelta}`);\n\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n              // DEBUG.push(`  -> delta: ${delta}`);\n            }\n          }\n        }\n      }\n\n      {\n        // Check if we should collapse a panel at its minimum size\n        const index = delta < 0 ? firstPivotIndex : secondPivotIndex;\n        const panelConstraints = panelConstraintsArray[index];\n        assert(panelConstraints, `No panel constraints found for index ${index}`);\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panelConstraints;\n\n        // DEBUG.push(`edge case check 2: ${index}`);\n        // DEBUG.push(`  -> collapsible? ${collapsible}`);\n        if (collapsible) {\n          const prevSize = initialLayout[index];\n          assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n          if (fuzzyNumbersEqual(prevSize, minSize)) {\n            const localDelta = prevSize - collapsedSize;\n            // DEBUG.push(`  -> expand delta: ${localDelta}`);\n\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n              // DEBUG.push(`  -> delta: ${delta}`);\n            }\n          }\n        }\n      }\n    }\n    // DEBUG.push(\"\");\n  }\n\n  {\n    // Pre-calculate max available delta in the opposite direction of our pivot.\n    // This will be the maximum amount we're allowed to expand/contract the panels in the primary direction.\n    // If this amount is less than the requested delta, adjust the requested delta.\n    // If this amount is greater than the requested delta, that's useful information tooâ€“\n    // as an expanding panel might change from collapsed to min size.\n\n    const increment = delta < 0 ? 1 : -1;\n    let index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    let maxAvailableDelta = 0;\n\n    // DEBUG.push(\"pre calc...\");\n    while (true) {\n      const prevSize = initialLayout[index];\n      assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n      const maxSafeSize = resizePanel({\n        panelConstraints: panelConstraintsArray,\n        panelIndex: index,\n        size: 100\n      });\n      const delta = maxSafeSize - prevSize;\n      // DEBUG.push(`  ${index}: ${prevSize} -> ${maxSafeSize}`);\n\n      maxAvailableDelta += delta;\n      index += increment;\n      if (index < 0 || index >= panelConstraintsArray.length) {\n        break;\n      }\n    }\n\n    // DEBUG.push(`  -> max available delta: ${maxAvailableDelta}`);\n    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));\n    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;\n    // DEBUG.push(`  -> adjusted delta: ${delta}`);\n    // DEBUG.push(\"\");\n  }\n\n  {\n    // Delta added to a panel needs to be subtracted from other panels (within the constraints that those panels allow).\n\n    const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;\n    let index = pivotIndex;\n    while (index >= 0 && index < panelConstraintsArray.length) {\n      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);\n      const prevSize = initialLayout[index];\n      assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n      const unsafeSize = prevSize - deltaRemaining;\n      const safeSize = resizePanel({\n        panelConstraints: panelConstraintsArray,\n        panelIndex: index,\n        size: unsafeSize\n      });\n      if (!fuzzyNumbersEqual(prevSize, safeSize)) {\n        deltaApplied += prevSize - safeSize;\n        nextLayout[index] = safeSize;\n        if (deltaApplied.toPrecision(3).localeCompare(Math.abs(delta).toPrecision(3), undefined, {\n          numeric: true\n        }) >= 0) {\n          break;\n        }\n      }\n      if (delta < 0) {\n        index--;\n      } else {\n        index++;\n      }\n    }\n  }\n  // DEBUG.push(`after 1: ${nextLayout.join(\", \")}`);\n  // DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n  // DEBUG.push(\"\");\n\n  // If we were unable to resize any of the panels panels, return the previous state.\n  // This will essentially bailout and ignore e.g. drags past a panel's boundaries\n  if (fuzzyLayoutsEqual(prevLayout, nextLayout)) {\n    // DEBUG.push(`bailout to previous layout: ${prevLayout.join(\", \")}`);\n    // console.log(DEBUG.join(\"\\n\"));\n\n    return prevLayout;\n  }\n  {\n    // Now distribute the applied delta to the panels in the other direction\n    const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    const prevSize = initialLayout[pivotIndex];\n    assert(prevSize != null, `Previous layout not found for panel index ${pivotIndex}`);\n    const unsafeSize = prevSize + deltaApplied;\n    const safeSize = resizePanel({\n      panelConstraints: panelConstraintsArray,\n      panelIndex: pivotIndex,\n      size: unsafeSize\n    });\n\n    // Adjust the pivot panel before, but only by the amount that surrounding panels were able to shrink/contract.\n    nextLayout[pivotIndex] = safeSize;\n\n    // Edge case where expanding or contracting one panel caused another one to change collapsed state\n    if (!fuzzyNumbersEqual(safeSize, unsafeSize)) {\n      let deltaRemaining = unsafeSize - safeSize;\n      const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n      let index = pivotIndex;\n      while (index >= 0 && index < panelConstraintsArray.length) {\n        const prevSize = nextLayout[index];\n        assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n        const unsafeSize = prevSize + deltaRemaining;\n        const safeSize = resizePanel({\n          panelConstraints: panelConstraintsArray,\n          panelIndex: index,\n          size: unsafeSize\n        });\n        if (!fuzzyNumbersEqual(prevSize, safeSize)) {\n          deltaRemaining -= safeSize - prevSize;\n          nextLayout[index] = safeSize;\n        }\n        if (fuzzyNumbersEqual(deltaRemaining, 0)) {\n          break;\n        }\n        if (delta > 0) {\n          index--;\n        } else {\n          index++;\n        }\n      }\n    }\n  }\n  // DEBUG.push(`after 2: ${nextLayout.join(\", \")}`);\n  // DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n  // DEBUG.push(\"\");\n\n  const totalSize = nextLayout.reduce((total, size) => size + total, 0);\n  // DEBUG.push(`total size: ${totalSize}`);\n\n  // If our new layout doesn't add up to 100%, that means the requested delta can't be applied\n  // In that case, fall back to our most recent valid layout\n  if (!fuzzyNumbersEqual(totalSize, 100)) {\n    // DEBUG.push(`bailout to previous layout: ${prevLayout.join(\", \")}`);\n    // console.log(DEBUG.join(\"\\n\"));\n\n    return prevLayout;\n  }\n\n  // console.log(DEBUG.join(\"\\n\"));\n  return nextLayout;\n}\n\nfunction calculateAriaValues({\n  layout,\n  panelsArray,\n  pivotIndices\n}) {\n  let currentMinSize = 0;\n  let currentMaxSize = 100;\n  let totalMinSize = 0;\n  let totalMaxSize = 0;\n  const firstIndex = pivotIndices[0];\n  assert(firstIndex != null, \"No pivot index found\");\n\n  // A panel's effective min/max sizes also need to account for other panel's sizes.\n  panelsArray.forEach((panelData, index) => {\n    const {\n      constraints\n    } = panelData;\n    const {\n      maxSize = 100,\n      minSize = 0\n    } = constraints;\n    if (index === firstIndex) {\n      currentMinSize = minSize;\n      currentMaxSize = maxSize;\n    } else {\n      totalMinSize += minSize;\n      totalMaxSize += maxSize;\n    }\n  });\n  const valueMax = Math.min(currentMaxSize, 100 - totalMinSize);\n  const valueMin = Math.max(currentMinSize, 100 - totalMaxSize);\n  const valueNow = layout[firstIndex];\n  return {\n    valueMax,\n    valueMin,\n    valueNow\n  };\n}\n\nfunction getResizeHandleElementsForGroup(groupId, scope = document) {\n  return Array.from(scope.querySelectorAll(`[data-panel-resize-handle-id][data-panel-group-id=\"${groupId}\"]`));\n}\n\nfunction getResizeHandleElementIndex(groupId, id, scope = document) {\n  const handles = getResizeHandleElementsForGroup(groupId, scope);\n  const index = handles.findIndex(handle => handle.getAttribute(\"data-panel-resize-handle-id\") === id);\n  return index !== null && index !== void 0 ? index : null;\n}\n\nfunction determinePivotIndices(groupId, dragHandleId, panelGroupElement) {\n  const index = getResizeHandleElementIndex(groupId, dragHandleId, panelGroupElement);\n  return index != null ? [index, index + 1] : [-1, -1];\n}\n\nfunction getPanelGroupElement(id, rootElement = document) {\n  var _dataset;\n  //If the root element is the PanelGroup\n  if (rootElement instanceof HTMLElement && (rootElement === null || rootElement === void 0 ? void 0 : (_dataset = rootElement.dataset) === null || _dataset === void 0 ? void 0 : _dataset.panelGroupId) == id) {\n    return rootElement;\n  }\n\n  //Else query children\n  const element = rootElement.querySelector(`[data-panel-group][data-panel-group-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\n\nfunction getResizeHandleElement(id, scope = document) {\n  const element = scope.querySelector(`[data-panel-resize-handle-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\n\nfunction getResizeHandlePanelIds(groupId, handleId, panelsArray, scope = document) {\n  var _panelsArray$index$id, _panelsArray$index, _panelsArray$id, _panelsArray;\n  const handle = getResizeHandleElement(handleId, scope);\n  const handles = getResizeHandleElementsForGroup(groupId, scope);\n  const index = handle ? handles.indexOf(handle) : -1;\n  const idBefore = (_panelsArray$index$id = (_panelsArray$index = panelsArray[index]) === null || _panelsArray$index === void 0 ? void 0 : _panelsArray$index.id) !== null && _panelsArray$index$id !== void 0 ? _panelsArray$index$id : null;\n  const idAfter = (_panelsArray$id = (_panelsArray = panelsArray[index + 1]) === null || _panelsArray === void 0 ? void 0 : _panelsArray.id) !== null && _panelsArray$id !== void 0 ? _panelsArray$id : null;\n  return [idBefore, idAfter];\n}\n\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\n\nfunction useWindowSplitterPanelGroupBehavior({\n  committedValuesRef,\n  eagerValuesRef,\n  groupId,\n  layout,\n  panelDataArray,\n  panelGroupElement,\n  setLayout\n}) {\n  useRef({\n    didWarnAboutMissingResizeHandle: false\n  });\n  useIsomorphicLayoutEffect(() => {\n    if (!panelGroupElement) {\n      return;\n    }\n    const resizeHandleElements = getResizeHandleElementsForGroup(groupId, panelGroupElement);\n    for (let index = 0; index < panelDataArray.length - 1; index++) {\n      const {\n        valueMax,\n        valueMin,\n        valueNow\n      } = calculateAriaValues({\n        layout,\n        panelsArray: panelDataArray,\n        pivotIndices: [index, index + 1]\n      });\n      const resizeHandleElement = resizeHandleElements[index];\n      if (resizeHandleElement == null) ; else {\n        const panelData = panelDataArray[index];\n        assert(panelData, `No panel data found for index \"${index}\"`);\n        resizeHandleElement.setAttribute(\"aria-controls\", panelData.id);\n        resizeHandleElement.setAttribute(\"aria-valuemax\", \"\" + Math.round(valueMax));\n        resizeHandleElement.setAttribute(\"aria-valuemin\", \"\" + Math.round(valueMin));\n        resizeHandleElement.setAttribute(\"aria-valuenow\", valueNow != null ? \"\" + Math.round(valueNow) : \"\");\n      }\n    }\n    return () => {\n      resizeHandleElements.forEach((resizeHandleElement, index) => {\n        resizeHandleElement.removeAttribute(\"aria-controls\");\n        resizeHandleElement.removeAttribute(\"aria-valuemax\");\n        resizeHandleElement.removeAttribute(\"aria-valuemin\");\n        resizeHandleElement.removeAttribute(\"aria-valuenow\");\n      });\n    };\n  }, [groupId, layout, panelDataArray, panelGroupElement]);\n  useEffect(() => {\n    if (!panelGroupElement) {\n      return;\n    }\n    const eagerValues = eagerValuesRef.current;\n    assert(eagerValues, `Eager values not found`);\n    const {\n      panelDataArray\n    } = eagerValues;\n    const groupElement = getPanelGroupElement(groupId, panelGroupElement);\n    assert(groupElement != null, `No group found for id \"${groupId}\"`);\n    const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);\n    assert(handles, `No resize handles found for group id \"${groupId}\"`);\n    const cleanupFunctions = handles.map(handle => {\n      const handleId = handle.getAttribute(\"data-panel-resize-handle-id\");\n      assert(handleId, `Resize handle element has no handle id attribute`);\n      const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelDataArray, panelGroupElement);\n      if (idBefore == null || idAfter == null) {\n        return () => {};\n      }\n      const onKeyDown = event => {\n        if (event.defaultPrevented) {\n          return;\n        }\n        switch (event.key) {\n          case \"Enter\":\n            {\n              event.preventDefault();\n              const index = panelDataArray.findIndex(panelData => panelData.id === idBefore);\n              if (index >= 0) {\n                const panelData = panelDataArray[index];\n                assert(panelData, `No panel data found for index ${index}`);\n                const size = layout[index];\n                const {\n                  collapsedSize = 0,\n                  collapsible,\n                  minSize = 0\n                } = panelData.constraints;\n                if (size != null && collapsible) {\n                  const nextLayout = adjustLayoutByDelta({\n                    delta: fuzzyNumbersEqual(size, collapsedSize) ? minSize - collapsedSize : collapsedSize - size,\n                    initialLayout: layout,\n                    panelConstraints: panelDataArray.map(panelData => panelData.constraints),\n                    pivotIndices: determinePivotIndices(groupId, handleId, panelGroupElement),\n                    prevLayout: layout,\n                    trigger: \"keyboard\"\n                  });\n                  if (layout !== nextLayout) {\n                    setLayout(nextLayout);\n                  }\n                }\n              }\n              break;\n            }\n        }\n      };\n      handle.addEventListener(\"keydown\", onKeyDown);\n      return () => {\n        handle.removeEventListener(\"keydown\", onKeyDown);\n      };\n    });\n    return () => {\n      cleanupFunctions.forEach(cleanupFunction => cleanupFunction());\n    };\n  }, [panelGroupElement, committedValuesRef, eagerValuesRef, groupId, layout, panelDataArray, setLayout]);\n}\n\nfunction areEqual(arrayA, arrayB) {\n  if (arrayA.length !== arrayB.length) {\n    return false;\n  }\n  for (let index = 0; index < arrayA.length; index++) {\n    if (arrayA[index] !== arrayB[index]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction getResizeEventCursorPosition(direction, event) {\n  const isHorizontal = direction === \"horizontal\";\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n  return isHorizontal ? x : y;\n}\n\nfunction calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement) {\n  const isHorizontal = direction === \"horizontal\";\n  const handleElement = getResizeHandleElement(dragHandleId, panelGroupElement);\n  assert(handleElement, `No resize handle element found for id \"${dragHandleId}\"`);\n  const groupId = handleElement.getAttribute(\"data-panel-group-id\");\n  assert(groupId, `Resize handle element has no group id attribute`);\n  let {\n    initialCursorPosition\n  } = initialDragState;\n  const cursorPosition = getResizeEventCursorPosition(direction, event);\n  const groupElement = getPanelGroupElement(groupId, panelGroupElement);\n  assert(groupElement, `No group element found for id \"${groupId}\"`);\n  const groupRect = groupElement.getBoundingClientRect();\n  const groupSizeInPixels = isHorizontal ? groupRect.width : groupRect.height;\n  const offsetPixels = cursorPosition - initialCursorPosition;\n  const offsetPercentage = offsetPixels / groupSizeInPixels * 100;\n  return offsetPercentage;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX\nfunction calculateDeltaPercentage(event, dragHandleId, direction, initialDragState, keyboardResizeBy, panelGroupElement) {\n  if (isKeyDown(event)) {\n    const isHorizontal = direction === \"horizontal\";\n    let delta = 0;\n    if (event.shiftKey) {\n      delta = 100;\n    } else if (keyboardResizeBy != null) {\n      delta = keyboardResizeBy;\n    } else {\n      delta = 10;\n    }\n    let movement = 0;\n    switch (event.key) {\n      case \"ArrowDown\":\n        movement = isHorizontal ? 0 : delta;\n        break;\n      case \"ArrowLeft\":\n        movement = isHorizontal ? -delta : 0;\n        break;\n      case \"ArrowRight\":\n        movement = isHorizontal ? delta : 0;\n        break;\n      case \"ArrowUp\":\n        movement = isHorizontal ? 0 : -delta;\n        break;\n      case \"End\":\n        movement = 100;\n        break;\n      case \"Home\":\n        movement = -100;\n        break;\n    }\n    return movement;\n  } else {\n    if (initialDragState == null) {\n      return 0;\n    }\n    return calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement);\n  }\n}\n\nfunction calculateUnsafeDefaultLayout({\n  panelDataArray\n}) {\n  const layout = Array(panelDataArray.length);\n  const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n  let numPanelsWithSizes = 0;\n  let remainingSize = 100;\n\n  // Distribute default sizes first\n  for (let index = 0; index < panelDataArray.length; index++) {\n    const panelConstraints = panelConstraintsArray[index];\n    assert(panelConstraints, `Panel constraints not found for index ${index}`);\n    const {\n      defaultSize\n    } = panelConstraints;\n    if (defaultSize != null) {\n      numPanelsWithSizes++;\n      layout[index] = defaultSize;\n      remainingSize -= defaultSize;\n    }\n  }\n\n  // Remaining size should be distributed evenly between panels without default sizes\n  for (let index = 0; index < panelDataArray.length; index++) {\n    const panelConstraints = panelConstraintsArray[index];\n    assert(panelConstraints, `Panel constraints not found for index ${index}`);\n    const {\n      defaultSize\n    } = panelConstraints;\n    if (defaultSize != null) {\n      continue;\n    }\n    const numRemainingPanels = panelDataArray.length - numPanelsWithSizes;\n    const size = remainingSize / numRemainingPanels;\n    numPanelsWithSizes++;\n    layout[index] = size;\n    remainingSize -= size;\n  }\n  return layout;\n}\n\n// Layout should be pre-converted into percentages\nfunction callPanelCallbacks(panelsArray, layout, panelIdToLastNotifiedSizeMap) {\n  layout.forEach((size, index) => {\n    const panelData = panelsArray[index];\n    assert(panelData, `Panel data not found for index ${index}`);\n    const {\n      callbacks,\n      constraints,\n      id: panelId\n    } = panelData;\n    const {\n      collapsedSize = 0,\n      collapsible\n    } = constraints;\n    const lastNotifiedSize = panelIdToLastNotifiedSizeMap[panelId];\n    if (lastNotifiedSize == null || size !== lastNotifiedSize) {\n      panelIdToLastNotifiedSizeMap[panelId] = size;\n      const {\n        onCollapse,\n        onExpand,\n        onResize\n      } = callbacks;\n      if (onResize) {\n        onResize(size, lastNotifiedSize);\n      }\n      if (collapsible && (onCollapse || onExpand)) {\n        if (onExpand && (lastNotifiedSize == null || fuzzyNumbersEqual$1(lastNotifiedSize, collapsedSize)) && !fuzzyNumbersEqual$1(size, collapsedSize)) {\n          onExpand();\n        }\n        if (onCollapse && (lastNotifiedSize == null || !fuzzyNumbersEqual$1(lastNotifiedSize, collapsedSize)) && fuzzyNumbersEqual$1(size, collapsedSize)) {\n          onCollapse();\n        }\n      }\n    }\n  });\n}\n\nfunction compareLayouts(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  } else {\n    for (let index = 0; index < a.length; index++) {\n      if (a[index] != b[index]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n// This method returns a number between 1 and 100 representing\n\n// the % of the group's overall space this panel should occupy.\nfunction computePanelFlexBoxStyle({\n  defaultSize,\n  dragState,\n  layout,\n  panelData,\n  panelIndex,\n  precision = 3\n}) {\n  const size = layout[panelIndex];\n  let flexGrow;\n  if (size == null) {\n    // Initial render (before panels have registered themselves)\n    // In order to support server rendering, fall back to default size if provided\n    flexGrow = defaultSize != undefined ? defaultSize.toPrecision(precision) : \"1\";\n  } else if (panelData.length === 1) {\n    // Special case: Single panel group should always fill full width/height\n    flexGrow = \"1\";\n  } else {\n    flexGrow = size.toPrecision(precision);\n  }\n  return {\n    flexBasis: 0,\n    flexGrow,\n    flexShrink: 1,\n    // Without this, Panel sizes may be unintentionally overridden by their content\n    overflow: \"hidden\",\n    // Disable pointer events inside of a panel during resize\n    // This avoid edge cases like nested iframes\n    pointerEvents: dragState !== null ? \"none\" : undefined\n  };\n}\n\nfunction debounce(callback, durationMs = 10) {\n  let timeoutId = null;\n  let callable = (...args) => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => {\n      callback(...args);\n    }, durationMs);\n  };\n  return callable;\n}\n\n// PanelGroup might be rendering in a server-side environment where localStorage is not available\n// or on a browser with cookies/storage disabled.\n// In either case, this function avoids accessing localStorage until needed,\n// and avoids throwing user-visible errors.\nfunction initializeDefaultStorage(storageObject) {\n  try {\n    if (typeof localStorage !== \"undefined\") {\n      // Bypass this check for future calls\n      storageObject.getItem = name => {\n        return localStorage.getItem(name);\n      };\n      storageObject.setItem = (name, value) => {\n        localStorage.setItem(name, value);\n      };\n    } else {\n      throw new Error(\"localStorage not supported in this environment\");\n    }\n  } catch (error) {\n    console.error(error);\n    storageObject.getItem = () => null;\n    storageObject.setItem = () => {};\n  }\n}\n\nfunction getPanelGroupKey(autoSaveId) {\n  return `react-resizable-panels:${autoSaveId}`;\n}\n\n// Note that Panel ids might be user-provided (stable) or useId generated (non-deterministic)\n// so they should not be used as part of the serialization key.\n// Using the min/max size attributes should work well enough as a backup.\n// Pre-sorting by minSize allows remembering layouts even if panels are re-ordered/dragged.\nfunction getPanelKey(panels) {\n  return panels.map(panel => {\n    const {\n      constraints,\n      id,\n      idIsFromProps,\n      order\n    } = panel;\n    if (idIsFromProps) {\n      return id;\n    } else {\n      return order ? `${order}:${JSON.stringify(constraints)}` : JSON.stringify(constraints);\n    }\n  }).sort((a, b) => a.localeCompare(b)).join(\",\");\n}\nfunction loadSerializedPanelGroupState(autoSaveId, storage) {\n  try {\n    const panelGroupKey = getPanelGroupKey(autoSaveId);\n    const serialized = storage.getItem(panelGroupKey);\n    if (serialized) {\n      const parsed = JSON.parse(serialized);\n      if (typeof parsed === \"object\" && parsed != null) {\n        return parsed;\n      }\n    }\n  } catch (error) {}\n  return null;\n}\nfunction loadPanelGroupState(autoSaveId, panels, storage) {\n  var _loadSerializedPanelG, _state$panelKey;\n  const state = (_loadSerializedPanelG = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG !== void 0 ? _loadSerializedPanelG : {};\n  const panelKey = getPanelKey(panels);\n  return (_state$panelKey = state[panelKey]) !== null && _state$panelKey !== void 0 ? _state$panelKey : null;\n}\nfunction savePanelGroupState(autoSaveId, panels, panelSizesBeforeCollapse, sizes, storage) {\n  var _loadSerializedPanelG2;\n  const panelGroupKey = getPanelGroupKey(autoSaveId);\n  const panelKey = getPanelKey(panels);\n  const state = (_loadSerializedPanelG2 = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG2 !== void 0 ? _loadSerializedPanelG2 : {};\n  state[panelKey] = {\n    expandToSizes: Object.fromEntries(panelSizesBeforeCollapse.entries()),\n    layout: sizes\n  };\n  try {\n    storage.setItem(panelGroupKey, JSON.stringify(state));\n  } catch (error) {\n    console.error(error);\n  }\n}\n\n// All units must be in percentages; pixel values should be pre-converted\nfunction validatePanelGroupLayout({\n  layout: prevLayout,\n  panelConstraints\n}) {\n  const nextLayout = [...prevLayout];\n  const nextLayoutTotalSize = nextLayout.reduce((accumulated, current) => accumulated + current, 0);\n\n  // Validate layout expectations\n  if (nextLayout.length !== panelConstraints.length) {\n    throw Error(`Invalid ${panelConstraints.length} panel layout: ${nextLayout.map(size => `${size}%`).join(\", \")}`);\n  } else if (!fuzzyNumbersEqual(nextLayoutTotalSize, 100) && nextLayout.length > 0) {\n    for (let index = 0; index < panelConstraints.length; index++) {\n      const unsafeSize = nextLayout[index];\n      assert(unsafeSize != null, `No layout data found for index ${index}`);\n      const safeSize = 100 / nextLayoutTotalSize * unsafeSize;\n      nextLayout[index] = safeSize;\n    }\n  }\n  let remainingSize = 0;\n\n  // First pass: Validate the proposed layout given each panel's constraints\n  for (let index = 0; index < panelConstraints.length; index++) {\n    const unsafeSize = nextLayout[index];\n    assert(unsafeSize != null, `No layout data found for index ${index}`);\n    const safeSize = resizePanel({\n      panelConstraints,\n      panelIndex: index,\n      size: unsafeSize\n    });\n    if (unsafeSize != safeSize) {\n      remainingSize += unsafeSize - safeSize;\n      nextLayout[index] = safeSize;\n    }\n  }\n\n  // If there is additional, left over space, assign it to any panel(s) that permits it\n  // (It's not worth taking multiple additional passes to evenly distribute)\n  if (!fuzzyNumbersEqual(remainingSize, 0)) {\n    for (let index = 0; index < panelConstraints.length; index++) {\n      const prevSize = nextLayout[index];\n      assert(prevSize != null, `No layout data found for index ${index}`);\n      const unsafeSize = prevSize + remainingSize;\n      const safeSize = resizePanel({\n        panelConstraints,\n        panelIndex: index,\n        size: unsafeSize\n      });\n      if (prevSize !== safeSize) {\n        remainingSize -= safeSize - prevSize;\n        nextLayout[index] = safeSize;\n\n        // Once we've used up the remainder, bail\n        if (fuzzyNumbersEqual(remainingSize, 0)) {\n          break;\n        }\n      }\n    }\n  }\n  return nextLayout;\n}\n\nconst LOCAL_STORAGE_DEBOUNCE_INTERVAL = 100;\nconst defaultStorage = {\n  getItem: name => {\n    initializeDefaultStorage(defaultStorage);\n    return defaultStorage.getItem(name);\n  },\n  setItem: (name, value) => {\n    initializeDefaultStorage(defaultStorage);\n    defaultStorage.setItem(name, value);\n  }\n};\nconst debounceMap = {};\nfunction PanelGroupWithForwardedRef({\n  autoSaveId = null,\n  children,\n  className: classNameFromProps = \"\",\n  direction,\n  forwardedRef,\n  id: idFromProps = null,\n  onLayout = null,\n  keyboardResizeBy = null,\n  storage = defaultStorage,\n  style: styleFromProps,\n  tagName: Type = \"div\",\n  ...rest\n}) {\n  const groupId = useUniqueId(idFromProps);\n  const panelGroupElementRef = useRef(null);\n  const [dragState, setDragState] = useState(null);\n  const [layout, setLayout] = useState([]);\n  const forceUpdate = useForceUpdate();\n  const panelIdToLastNotifiedSizeMapRef = useRef({});\n  const panelSizeBeforeCollapseRef = useRef(new Map());\n  const prevDeltaRef = useRef(0);\n  const committedValuesRef = useRef({\n    autoSaveId,\n    direction,\n    dragState,\n    id: groupId,\n    keyboardResizeBy,\n    onLayout,\n    storage\n  });\n  const eagerValuesRef = useRef({\n    layout,\n    panelDataArray: [],\n    panelDataArrayChanged: false\n  });\n  useRef({\n    didLogIdAndOrderWarning: false,\n    didLogPanelConstraintsWarning: false,\n    prevPanelIds: []\n  });\n  useImperativeHandle(forwardedRef, () => ({\n    getId: () => committedValuesRef.current.id,\n    getLayout: () => {\n      const {\n        layout\n      } = eagerValuesRef.current;\n      return layout;\n    },\n    setLayout: unsafeLayout => {\n      const {\n        onLayout\n      } = committedValuesRef.current;\n      const {\n        layout: prevLayout,\n        panelDataArray\n      } = eagerValuesRef.current;\n      const safeLayout = validatePanelGroupLayout({\n        layout: unsafeLayout,\n        panelConstraints: panelDataArray.map(panelData => panelData.constraints)\n      });\n      if (!areEqual(prevLayout, safeLayout)) {\n        setLayout(safeLayout);\n        eagerValuesRef.current.layout = safeLayout;\n        if (onLayout) {\n          onLayout(safeLayout);\n        }\n        callPanelCallbacks(panelDataArray, safeLayout, panelIdToLastNotifiedSizeMapRef.current);\n      }\n    }\n  }), []);\n  useIsomorphicLayoutEffect(() => {\n    committedValuesRef.current.autoSaveId = autoSaveId;\n    committedValuesRef.current.direction = direction;\n    committedValuesRef.current.dragState = dragState;\n    committedValuesRef.current.id = groupId;\n    committedValuesRef.current.onLayout = onLayout;\n    committedValuesRef.current.storage = storage;\n  });\n  useWindowSplitterPanelGroupBehavior({\n    committedValuesRef,\n    eagerValuesRef,\n    groupId,\n    layout,\n    panelDataArray: eagerValuesRef.current.panelDataArray,\n    setLayout,\n    panelGroupElement: panelGroupElementRef.current\n  });\n  useEffect(() => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n\n    // If this panel has been configured to persist sizing information, save sizes to local storage.\n    if (autoSaveId) {\n      if (layout.length === 0 || layout.length !== panelDataArray.length) {\n        return;\n      }\n      let debouncedSave = debounceMap[autoSaveId];\n\n      // Limit the frequency of localStorage updates.\n      if (debouncedSave == null) {\n        debouncedSave = debounce(savePanelGroupState, LOCAL_STORAGE_DEBOUNCE_INTERVAL);\n        debounceMap[autoSaveId] = debouncedSave;\n      }\n\n      // Clone mutable data before passing to the debounced function,\n      // else we run the risk of saving an incorrect combination of mutable and immutable values to state.\n      const clonedPanelDataArray = [...panelDataArray];\n      const clonedPanelSizesBeforeCollapse = new Map(panelSizeBeforeCollapseRef.current);\n      debouncedSave(autoSaveId, clonedPanelDataArray, clonedPanelSizesBeforeCollapse, layout, storage);\n    }\n  }, [autoSaveId, layout, storage]);\n\n  // DEV warnings\n  useEffect(() => {\n  });\n\n  // External APIs are safe to memoize via committed values ref\n  const collapsePanel = useCallback(panelData => {\n    const {\n      onLayout\n    } = committedValuesRef.current;\n    const {\n      layout: prevLayout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    if (panelData.constraints.collapsible) {\n      const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n      const {\n        collapsedSize = 0,\n        panelSize,\n        pivotIndices\n      } = panelDataHelper(panelDataArray, panelData, prevLayout);\n      assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n      if (!fuzzyNumbersEqual$1(panelSize, collapsedSize)) {\n        // Store size before collapse;\n        // This is the size that gets restored if the expand() API is used.\n        panelSizeBeforeCollapseRef.current.set(panelData.id, panelSize);\n        const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n        const delta = isLastPanel ? panelSize - collapsedSize : collapsedSize - panelSize;\n        const nextLayout = adjustLayoutByDelta({\n          delta,\n          initialLayout: prevLayout,\n          panelConstraints: panelConstraintsArray,\n          pivotIndices,\n          prevLayout,\n          trigger: \"imperative-api\"\n        });\n        if (!compareLayouts(prevLayout, nextLayout)) {\n          setLayout(nextLayout);\n          eagerValuesRef.current.layout = nextLayout;\n          if (onLayout) {\n            onLayout(nextLayout);\n          }\n          callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n        }\n      }\n    }\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const expandPanel = useCallback((panelData, minSizeOverride) => {\n    const {\n      onLayout\n    } = committedValuesRef.current;\n    const {\n      layout: prevLayout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    if (panelData.constraints.collapsible) {\n      const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n      const {\n        collapsedSize = 0,\n        panelSize = 0,\n        minSize: minSizeFromProps = 0,\n        pivotIndices\n      } = panelDataHelper(panelDataArray, panelData, prevLayout);\n      const minSize = minSizeOverride !== null && minSizeOverride !== void 0 ? minSizeOverride : minSizeFromProps;\n      if (fuzzyNumbersEqual$1(panelSize, collapsedSize)) {\n        // Restore this panel to the size it was before it was collapsed, if possible.\n        const prevPanelSize = panelSizeBeforeCollapseRef.current.get(panelData.id);\n        const baseSize = prevPanelSize != null && prevPanelSize >= minSize ? prevPanelSize : minSize;\n        const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n        const delta = isLastPanel ? panelSize - baseSize : baseSize - panelSize;\n        const nextLayout = adjustLayoutByDelta({\n          delta,\n          initialLayout: prevLayout,\n          panelConstraints: panelConstraintsArray,\n          pivotIndices,\n          prevLayout,\n          trigger: \"imperative-api\"\n        });\n        if (!compareLayouts(prevLayout, nextLayout)) {\n          setLayout(nextLayout);\n          eagerValuesRef.current.layout = nextLayout;\n          if (onLayout) {\n            onLayout(nextLayout);\n          }\n          callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n        }\n      }\n    }\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const getPanelSize = useCallback(panelData => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      panelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    return panelSize;\n  }, []);\n\n  // This API should never read from committedValuesRef\n  const getPanelStyle = useCallback((panelData, defaultSize) => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n    const panelIndex = findPanelDataIndex(panelDataArray, panelData);\n    return computePanelFlexBoxStyle({\n      defaultSize,\n      dragState,\n      layout,\n      panelData: panelDataArray,\n      panelIndex\n    });\n  }, [dragState, layout]);\n\n  // External APIs are safe to memoize via committed values ref\n  const isPanelCollapsed = useCallback(panelData => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      collapsedSize = 0,\n      collapsible,\n      panelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    return collapsible === true && fuzzyNumbersEqual$1(panelSize, collapsedSize);\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const isPanelExpanded = useCallback(panelData => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      collapsedSize = 0,\n      collapsible,\n      panelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    return !collapsible || fuzzyCompareNumbers(panelSize, collapsedSize) > 0;\n  }, []);\n  const registerPanel = useCallback(panelData => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n    panelDataArray.push(panelData);\n    panelDataArray.sort((panelA, panelB) => {\n      const orderA = panelA.order;\n      const orderB = panelB.order;\n      if (orderA == null && orderB == null) {\n        return 0;\n      } else if (orderA == null) {\n        return -1;\n      } else if (orderB == null) {\n        return 1;\n      } else {\n        return orderA - orderB;\n      }\n    });\n    eagerValuesRef.current.panelDataArrayChanged = true;\n    forceUpdate();\n  }, [forceUpdate]);\n\n  // (Re)calculate group layout whenever panels are registered or unregistered.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useIsomorphicLayoutEffect(() => {\n    if (eagerValuesRef.current.panelDataArrayChanged) {\n      eagerValuesRef.current.panelDataArrayChanged = false;\n      const {\n        autoSaveId,\n        onLayout,\n        storage\n      } = committedValuesRef.current;\n      const {\n        layout: prevLayout,\n        panelDataArray\n      } = eagerValuesRef.current;\n\n      // If this panel has been configured to persist sizing information,\n      // default size should be restored from local storage if possible.\n      let unsafeLayout = null;\n      if (autoSaveId) {\n        const state = loadPanelGroupState(autoSaveId, panelDataArray, storage);\n        if (state) {\n          panelSizeBeforeCollapseRef.current = new Map(Object.entries(state.expandToSizes));\n          unsafeLayout = state.layout;\n        }\n      }\n      if (unsafeLayout == null) {\n        unsafeLayout = calculateUnsafeDefaultLayout({\n          panelDataArray\n        });\n      }\n\n      // Validate even saved layouts in case something has changed since last render\n      // e.g. for pixel groups, this could be the size of the window\n      const nextLayout = validatePanelGroupLayout({\n        layout: unsafeLayout,\n        panelConstraints: panelDataArray.map(panelData => panelData.constraints)\n      });\n      if (!areEqual(prevLayout, nextLayout)) {\n        setLayout(nextLayout);\n        eagerValuesRef.current.layout = nextLayout;\n        if (onLayout) {\n          onLayout(nextLayout);\n        }\n        callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n      }\n    }\n  });\n\n  // Reset the cached layout if hidden by the Activity/Offscreen API\n  useIsomorphicLayoutEffect(() => {\n    const eagerValues = eagerValuesRef.current;\n    return () => {\n      eagerValues.layout = [];\n    };\n  }, []);\n  const registerResizeHandle = useCallback(dragHandleId => {\n    return function resizeHandler(event) {\n      event.preventDefault();\n      const panelGroupElement = panelGroupElementRef.current;\n      if (!panelGroupElement) {\n        return () => null;\n      }\n      const {\n        direction,\n        dragState,\n        id: groupId,\n        keyboardResizeBy,\n        onLayout\n      } = committedValuesRef.current;\n      const {\n        layout: prevLayout,\n        panelDataArray\n      } = eagerValuesRef.current;\n      const {\n        initialLayout\n      } = dragState !== null && dragState !== void 0 ? dragState : {};\n      const pivotIndices = determinePivotIndices(groupId, dragHandleId, panelGroupElement);\n      let delta = calculateDeltaPercentage(event, dragHandleId, direction, dragState, keyboardResizeBy, panelGroupElement);\n\n      // Support RTL layouts\n      const isHorizontal = direction === \"horizontal\";\n      if (document.dir === \"rtl\" && isHorizontal) {\n        delta = -delta;\n      }\n      const panelConstraints = panelDataArray.map(panelData => panelData.constraints);\n      const nextLayout = adjustLayoutByDelta({\n        delta,\n        initialLayout: initialLayout !== null && initialLayout !== void 0 ? initialLayout : prevLayout,\n        panelConstraints,\n        pivotIndices,\n        prevLayout,\n        trigger: isKeyDown(event) ? \"keyboard\" : \"mouse-or-touch\"\n      });\n      const layoutChanged = !compareLayouts(prevLayout, nextLayout);\n\n      // Only update the cursor for layout changes triggered by touch/mouse events (not keyboard)\n      // Update the cursor even if the layout hasn't changed (we may need to show an invalid cursor state)\n      if (isPointerEvent(event) || isMouseEvent(event)) {\n        // Watch for multiple subsequent deltas; this might occur for tiny cursor movements.\n        // In this case, Panel sizes might not changeâ€“\n        // but updating cursor in this scenario would cause a flicker.\n        if (prevDeltaRef.current != delta) {\n          prevDeltaRef.current = delta;\n          if (!layoutChanged && delta !== 0) {\n            // If the pointer has moved too far to resize the panel any further, note this so we can update the cursor.\n            // This mimics VS Code behavior.\n            if (isHorizontal) {\n              reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_HORIZONTAL_MIN : EXCEEDED_HORIZONTAL_MAX);\n            } else {\n              reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_VERTICAL_MIN : EXCEEDED_VERTICAL_MAX);\n            }\n          } else {\n            reportConstraintsViolation(dragHandleId, 0);\n          }\n        }\n      }\n      if (layoutChanged) {\n        setLayout(nextLayout);\n        eagerValuesRef.current.layout = nextLayout;\n        if (onLayout) {\n          onLayout(nextLayout);\n        }\n        callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n      }\n    };\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const resizePanel = useCallback((panelData, unsafePanelSize) => {\n    const {\n      onLayout\n    } = committedValuesRef.current;\n    const {\n      layout: prevLayout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n    const {\n      panelSize,\n      pivotIndices\n    } = panelDataHelper(panelDataArray, panelData, prevLayout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n    const delta = isLastPanel ? panelSize - unsafePanelSize : unsafePanelSize - panelSize;\n    const nextLayout = adjustLayoutByDelta({\n      delta,\n      initialLayout: prevLayout,\n      panelConstraints: panelConstraintsArray,\n      pivotIndices,\n      prevLayout,\n      trigger: \"imperative-api\"\n    });\n    if (!compareLayouts(prevLayout, nextLayout)) {\n      setLayout(nextLayout);\n      eagerValuesRef.current.layout = nextLayout;\n      if (onLayout) {\n        onLayout(nextLayout);\n      }\n      callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n    }\n  }, []);\n  const reevaluatePanelConstraints = useCallback((panelData, prevConstraints) => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      collapsedSize: prevCollapsedSize = 0,\n      collapsible: prevCollapsible\n    } = prevConstraints;\n    const {\n      collapsedSize: nextCollapsedSize = 0,\n      collapsible: nextCollapsible,\n      maxSize: nextMaxSize = 100,\n      minSize: nextMinSize = 0\n    } = panelData.constraints;\n    const {\n      panelSize: prevPanelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    if (prevPanelSize == null) {\n      // It's possible that the panels in this group have changed since the last render\n      return;\n    }\n    if (prevCollapsible && nextCollapsible && fuzzyNumbersEqual$1(prevPanelSize, prevCollapsedSize)) {\n      if (!fuzzyNumbersEqual$1(prevCollapsedSize, nextCollapsedSize)) {\n        resizePanel(panelData, nextCollapsedSize);\n      }\n    } else if (prevPanelSize < nextMinSize) {\n      resizePanel(panelData, nextMinSize);\n    } else if (prevPanelSize > nextMaxSize) {\n      resizePanel(panelData, nextMaxSize);\n    }\n  }, [resizePanel]);\n  const startDragging = useCallback((dragHandleId, event) => {\n    const {\n      direction\n    } = committedValuesRef.current;\n    const {\n      layout\n    } = eagerValuesRef.current;\n    if (!panelGroupElementRef.current) {\n      return;\n    }\n    const handleElement = getResizeHandleElement(dragHandleId, panelGroupElementRef.current);\n    assert(handleElement, `Drag handle element not found for id \"${dragHandleId}\"`);\n    const initialCursorPosition = getResizeEventCursorPosition(direction, event);\n    setDragState({\n      dragHandleId,\n      dragHandleRect: handleElement.getBoundingClientRect(),\n      initialCursorPosition,\n      initialLayout: layout\n    });\n  }, []);\n  const stopDragging = useCallback(() => {\n    setDragState(null);\n  }, []);\n  const unregisterPanel = useCallback(panelData => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n    const index = findPanelDataIndex(panelDataArray, panelData);\n    if (index >= 0) {\n      panelDataArray.splice(index, 1);\n\n      // TRICKY\n      // When a panel is removed from the group, we should delete the most recent prev-size entry for it.\n      // If we don't do this, then a conditionally rendered panel might not call onResize when it's re-mounted.\n      // Strict effects mode makes this tricky though because all panels will be registered, unregistered, then re-registered on mount.\n      delete panelIdToLastNotifiedSizeMapRef.current[panelData.id];\n      eagerValuesRef.current.panelDataArrayChanged = true;\n      forceUpdate();\n    }\n  }, [forceUpdate]);\n  const context = useMemo(() => ({\n    collapsePanel,\n    direction,\n    dragState,\n    expandPanel,\n    getPanelSize,\n    getPanelStyle,\n    groupId,\n    isPanelCollapsed,\n    isPanelExpanded,\n    reevaluatePanelConstraints,\n    registerPanel,\n    registerResizeHandle,\n    resizePanel,\n    startDragging,\n    stopDragging,\n    unregisterPanel,\n    panelGroupElement: panelGroupElementRef.current\n  }), [collapsePanel, dragState, direction, expandPanel, getPanelSize, getPanelStyle, groupId, isPanelCollapsed, isPanelExpanded, reevaluatePanelConstraints, registerPanel, registerResizeHandle, resizePanel, startDragging, stopDragging, unregisterPanel]);\n  const style = {\n    display: \"flex\",\n    flexDirection: direction === \"horizontal\" ? \"row\" : \"column\",\n    height: \"100%\",\n    overflow: \"hidden\",\n    width: \"100%\"\n  };\n  return createElement(PanelGroupContext.Provider, {\n    value: context\n  }, createElement(Type, {\n    ...rest,\n    children,\n    className: classNameFromProps,\n    id: idFromProps,\n    ref: panelGroupElementRef,\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    // CSS selectors\n    \"data-panel-group\": \"\",\n    \"data-panel-group-direction\": direction,\n    \"data-panel-group-id\": groupId\n  }));\n}\nconst PanelGroup = forwardRef((props, ref) => createElement(PanelGroupWithForwardedRef, {\n  ...props,\n  forwardedRef: ref\n}));\nPanelGroupWithForwardedRef.displayName = \"PanelGroup\";\nPanelGroup.displayName = \"forwardRef(PanelGroup)\";\nfunction findPanelDataIndex(panelDataArray, panelData) {\n  return panelDataArray.findIndex(prevPanelData => prevPanelData === panelData || prevPanelData.id === panelData.id);\n}\nfunction panelDataHelper(panelDataArray, panelData, layout) {\n  const panelIndex = findPanelDataIndex(panelDataArray, panelData);\n  const isLastPanel = panelIndex === panelDataArray.length - 1;\n  const pivotIndices = isLastPanel ? [panelIndex - 1, panelIndex] : [panelIndex, panelIndex + 1];\n  const panelSize = layout[panelIndex];\n  return {\n    ...panelData.constraints,\n    panelSize,\n    pivotIndices\n  };\n}\n\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\n\nfunction useWindowSplitterResizeHandlerBehavior({\n  disabled,\n  handleId,\n  resizeHandler,\n  panelGroupElement\n}) {\n  useEffect(() => {\n    if (disabled || resizeHandler == null || panelGroupElement == null) {\n      return;\n    }\n    const handleElement = getResizeHandleElement(handleId, panelGroupElement);\n    if (handleElement == null) {\n      return;\n    }\n    const onKeyDown = event => {\n      if (event.defaultPrevented) {\n        return;\n      }\n      switch (event.key) {\n        case \"ArrowDown\":\n        case \"ArrowLeft\":\n        case \"ArrowRight\":\n        case \"ArrowUp\":\n        case \"End\":\n        case \"Home\":\n          {\n            event.preventDefault();\n            resizeHandler(event);\n            break;\n          }\n        case \"F6\":\n          {\n            event.preventDefault();\n            const groupId = handleElement.getAttribute(\"data-panel-group-id\");\n            assert(groupId, `No group element found for id \"${groupId}\"`);\n            const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);\n            const index = getResizeHandleElementIndex(groupId, handleId, panelGroupElement);\n            assert(index !== null, `No resize element found for id \"${handleId}\"`);\n            const nextIndex = event.shiftKey ? index > 0 ? index - 1 : handles.length - 1 : index + 1 < handles.length ? index + 1 : 0;\n            const nextHandle = handles[nextIndex];\n            nextHandle.focus();\n            break;\n          }\n      }\n    };\n    handleElement.addEventListener(\"keydown\", onKeyDown);\n    return () => {\n      handleElement.removeEventListener(\"keydown\", onKeyDown);\n    };\n  }, [panelGroupElement, disabled, handleId, resizeHandler]);\n}\n\nfunction PanelResizeHandle({\n  children = null,\n  className: classNameFromProps = \"\",\n  disabled = false,\n  hitAreaMargins,\n  id: idFromProps,\n  onBlur,\n  onDragging,\n  onFocus,\n  style: styleFromProps = {},\n  tabIndex = 0,\n  tagName: Type = \"div\",\n  ...rest\n}) {\n  var _hitAreaMargins$coars, _hitAreaMargins$fine;\n  const elementRef = useRef(null);\n\n  // Use a ref to guard against users passing inline props\n  const callbacksRef = useRef({\n    onDragging\n  });\n  useEffect(() => {\n    callbacksRef.current.onDragging = onDragging;\n  });\n  const panelGroupContext = useContext(PanelGroupContext);\n  if (panelGroupContext === null) {\n    throw Error(`PanelResizeHandle components must be rendered within a PanelGroup container`);\n  }\n  const {\n    direction,\n    groupId,\n    registerResizeHandle: registerResizeHandleWithParentGroup,\n    startDragging,\n    stopDragging,\n    panelGroupElement\n  } = panelGroupContext;\n  const resizeHandleId = useUniqueId(idFromProps);\n  const [state, setState] = useState(\"inactive\");\n  const [isFocused, setIsFocused] = useState(false);\n  const [resizeHandler, setResizeHandler] = useState(null);\n  const committedValuesRef = useRef({\n    state\n  });\n  useIsomorphicLayoutEffect(() => {\n    committedValuesRef.current.state = state;\n  });\n  useEffect(() => {\n    if (disabled) {\n      setResizeHandler(null);\n    } else {\n      const resizeHandler = registerResizeHandleWithParentGroup(resizeHandleId);\n      setResizeHandler(() => resizeHandler);\n    }\n  }, [disabled, resizeHandleId, registerResizeHandleWithParentGroup]);\n\n  // Extract hit area margins before passing them to the effect's dependency array\n  // so that inline object values won't trigger re-renders\n  const coarseHitAreaMargins = (_hitAreaMargins$coars = hitAreaMargins === null || hitAreaMargins === void 0 ? void 0 : hitAreaMargins.coarse) !== null && _hitAreaMargins$coars !== void 0 ? _hitAreaMargins$coars : 15;\n  const fineHitAreaMargins = (_hitAreaMargins$fine = hitAreaMargins === null || hitAreaMargins === void 0 ? void 0 : hitAreaMargins.fine) !== null && _hitAreaMargins$fine !== void 0 ? _hitAreaMargins$fine : 5;\n  useEffect(() => {\n    if (disabled || resizeHandler == null) {\n      return;\n    }\n    const element = elementRef.current;\n    assert(element, \"Element ref not attached\");\n    const setResizeHandlerState = (action, isActive, event) => {\n      if (isActive) {\n        switch (action) {\n          case \"down\":\n            {\n              setState(\"drag\");\n              startDragging(resizeHandleId, event);\n              const {\n                onDragging\n              } = callbacksRef.current;\n              if (onDragging) {\n                onDragging(true);\n              }\n              break;\n            }\n          case \"move\":\n            {\n              const {\n                state\n              } = committedValuesRef.current;\n              if (state !== \"drag\") {\n                setState(\"hover\");\n              }\n              resizeHandler(event);\n              break;\n            }\n          case \"up\":\n            {\n              setState(\"hover\");\n              stopDragging();\n              const {\n                onDragging\n              } = callbacksRef.current;\n              if (onDragging) {\n                onDragging(false);\n              }\n              break;\n            }\n        }\n      } else {\n        setState(\"inactive\");\n      }\n    };\n    return registerResizeHandle(resizeHandleId, element, direction, {\n      coarse: coarseHitAreaMargins,\n      fine: fineHitAreaMargins\n    }, setResizeHandlerState);\n  }, [coarseHitAreaMargins, direction, disabled, fineHitAreaMargins, registerResizeHandleWithParentGroup, resizeHandleId, resizeHandler, startDragging, stopDragging]);\n  useWindowSplitterResizeHandlerBehavior({\n    disabled,\n    handleId: resizeHandleId,\n    resizeHandler,\n    panelGroupElement\n  });\n  const style = {\n    touchAction: \"none\",\n    userSelect: \"none\"\n  };\n  return createElement(Type, {\n    ...rest,\n    children,\n    className: classNameFromProps,\n    id: idFromProps,\n    onBlur: () => {\n      setIsFocused(false);\n      onBlur === null || onBlur === void 0 ? void 0 : onBlur();\n    },\n    onFocus: () => {\n      setIsFocused(true);\n      onFocus === null || onFocus === void 0 ? void 0 : onFocus();\n    },\n    ref: elementRef,\n    role: \"separator\",\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    tabIndex,\n    // CSS selectors\n    \"data-panel-group-direction\": direction,\n    \"data-panel-group-id\": groupId,\n    \"data-resize-handle\": \"\",\n    \"data-resize-handle-active\": state === \"drag\" ? \"pointer\" : isFocused ? \"keyboard\" : undefined,\n    \"data-resize-handle-state\": state,\n    \"data-panel-resize-handle-enabled\": !disabled,\n    \"data-panel-resize-handle-id\": resizeHandleId\n  });\n}\nPanelResizeHandle.displayName = \"PanelResizeHandle\";\n\nfunction getPanelElement(id, scope = document) {\n  const element = scope.querySelector(`[data-panel-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\n\nfunction getPanelElementsForGroup(groupId, scope = document) {\n  return Array.from(scope.querySelectorAll(`[data-panel][data-panel-group-id=\"${groupId}\"]`));\n}\n\nfunction getIntersectingRectangle(rectOne, rectTwo, strict) {\n  if (!intersects(rectOne, rectTwo, strict)) {\n    return {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n  }\n  return {\n    x: Math.max(rectOne.x, rectTwo.x),\n    y: Math.max(rectOne.y, rectTwo.y),\n    width: Math.min(rectOne.x + rectOne.width, rectTwo.x + rectTwo.width) - Math.max(rectOne.x, rectTwo.x),\n    height: Math.min(rectOne.y + rectOne.height, rectTwo.y + rectTwo.height) - Math.max(rectOne.y, rectTwo.y)\n  };\n}\n\nexport { Panel, PanelGroup, PanelResizeHandle, assert, disableGlobalCursorStyles, enableGlobalCursorStyles, getIntersectingRectangle, getPanelElement, getPanelElementsForGroup, getPanelGroupElement, getResizeHandleElement, getResizeHandleElementIndex, getResizeHandleElementsForGroup, getResizeHandlePanelIds, intersects, setNonce };\n"],"names":["createElement","createContext","createRef","forwardRef","useCallback","useContext","useEffect","useImperativeHandle","useLayoutEffect","useMemo","useRef","useState","useId","Math","random","slice","useLayoutEffect_do_not_use_directly","PanelGroupContext","displayName","useIsomorphicLayoutEffect","wrappedUseId","counter","useUniqueId","idFromParams","idFromUseId","idRef","current","PanelWithForwardedRef","children","className","classNameFromProps","collapsedSize","collapsible","defaultSize","forwardedRef","id","idFromProps","maxSize","minSize","onCollapse","onExpand","onResize","order","style","styleFromProps","tagName","Type","rest","context","Error","collapsePanel","expandPanel","getPanelSize","getPanelStyle","groupId","isPanelCollapsed","reevaluatePanelConstraints","registerPanel","resizePanel","unregisterPanel","panelId","panelDataRef","callbacks","constraints","idIsFromProps","undefined","didLogMissingDefaultSizeWarning","prevConstraints","panelData","collapse","expand","getId","getSize","isCollapsed","isExpanded","resize","size","parseFloat","flexGrow","toFixed","Panel","props","ref","nonce","getNonce","setNonce","value","currentCursorStyle","enabled","styleElement","disableGlobalCursorStyles","enableGlobalCursorStyles","setGlobalCursorStyle","state","constraintFlags","verticalMin","EXCEEDED_VERTICAL_MIN","verticalMax","EXCEEDED_VERTICAL_MAX","EXCEEDED_HORIZONTAL_MIN","EXCEEDED_HORIZONTAL_MAX","getCursorStyle","document","setAttribute","head","appendChild","innerHTML","isKeyDown","event","type","isPointerEvent","startsWith","isMouseEvent","getResizeEventCoordinates","isPrimary","x","clientX","y","clientY","Infinity","intersects","rectOne","rectTwo","strict","width","height","creates_stacking_context","node","getComputedStyle","position","zIndex","_get_parent","display","get_parent","is_flex_item","opacity","transform","webkitTransform","mixBlendMode","filter","webkitFilter","isolation","test","willChange","webkitOverflowScrolling","find_stacking_context","nodes","i","length","assert","get_z_index","Number","get_ancestors","ancestors","push","parentNode","ShadowRoot","host","isCoarsePointer","matchMedia","matches","getInputType","intersectingHandles","isPointerDown","ownerDocumentCounts","Map","panelConstraintFlags","registeredResizeHandlers","Set","handlePointerDown","target","recalculateIntersectingHandles","updateListeners","updateResizeHandlerStates","preventDefault","stopPropagation","handlePointerMove","buttons","updateCursor","handlePointerUp","clear","splice","targetElement","HTMLElement","forEach","data","element","dragHandleElement","hitAreaMargins","dragHandleRect","getBoundingClientRect","bottom","left","right","top","margin","coarse","fine","contains","a","b","common_ancestor","at","pop","z_indexes","childNodes","furthest_ancestors","child","sign","compare","currentElement","didIntersect","parentElement","intersectsHorizontal","intersectsVertical","direction","flag","removeChild","_","ownerDocument","body","removeEventListener","window","count","addEventListener","capture","action","setResizeHandlerState","isActive","includes","expectedCondition","message","console","error","PRECISION","fuzzyCompareNumbers","actual","expected","fractionDigits","fuzzyNumbersEqual$1","fuzzyNumbersEqual","panelConstraints","panelConstraintsArray","panelIndex","min","adjustLayoutByDelta","delta","initialLayout","pivotIndices","prevLayout","trigger","nextLayout","firstPivotIndex","secondPivotIndex","deltaApplied","index","prevSize","localDelta","abs","increment","maxAvailableDelta","minAbsDelta","deltaRemaining","safeSize","toPrecision","localeCompare","numeric","fuzzyLayoutsEqual","pivotIndex","unsafeSize","reduce","total","calculateAriaValues","layout","panelsArray","currentMinSize","currentMaxSize","totalMinSize","totalMaxSize","firstIndex","valueMax","valueMin","max","valueNow","getResizeHandleElementsForGroup","scope","Array","from","querySelectorAll","getResizeHandleElementIndex","findIndex","handle","getAttribute","determinePivotIndices","dragHandleId","panelGroupElement","getPanelGroupElement","rootElement","_dataset","dataset","panelGroupId","querySelector","getResizeHandleElement","getResizeHandlePanelIds","handleId","_panelsArray$index$id","_panelsArray$index","_panelsArray$id","_panelsArray","handles","indexOf","areEqual","arrayA","arrayB","getResizeEventCursorPosition","isHorizontal","callPanelCallbacks","panelIdToLastNotifiedSizeMap","lastNotifiedSize","compareLayouts","initializeDefaultStorage","storageObject","localStorage","getItem","name","setItem","getPanelGroupKey","autoSaveId","getPanelKey","panels","map","panel","JSON","stringify","sort","join","loadSerializedPanelGroupState","storage","panelGroupKey","serialized","parsed","parse","savePanelGroupState","panelSizesBeforeCollapse","sizes","_loadSerializedPanelG2","panelKey","expandToSizes","Object","fromEntries","entries","validatePanelGroupLayout","nextLayoutTotalSize","accumulated","remainingSize","defaultStorage","debounceMap","PanelGroupWithForwardedRef","onLayout","keyboardResizeBy","panelGroupElementRef","dragState","setDragState","setLayout","forceUpdate","setCount","prevCount","useForceUpdate","panelIdToLastNotifiedSizeMapRef","panelSizeBeforeCollapseRef","prevDeltaRef","committedValuesRef","eagerValuesRef","panelDataArray","panelDataArrayChanged","didLogIdAndOrderWarning","didLogPanelConstraintsWarning","prevPanelIds","getLayout","unsafeLayout","safeLayout","didWarnAboutMissingResizeHandle","resizeHandleElements","resizeHandleElement","round","removeAttribute","eagerValues","cleanupFunctions","idBefore","idAfter","onKeyDown","defaultPrevented","key","cleanupFunction","useWindowSplitterPanelGroupBehavior","debouncedSave","callback","durationMs","timeoutId","args","clearTimeout","setTimeout","debounce","clonedPanelDataArray","clonedPanelSizesBeforeCollapse","panelSize","panelDataHelper","set","findPanelDataIndex","minSizeOverride","minSizeFromProps","prevPanelSize","get","baseSize","precision","flexBasis","flexShrink","overflow","pointerEvents","computePanelFlexBoxStyle","isPanelExpanded","panelA","panelB","orderA","orderB","_loadSerializedPanelG","_state$panelKey","loadPanelGroupState","numPanelsWithSizes","calculateUnsafeDefaultLayout","registerResizeHandle","initialDragState","shiftKey","movement","handleElement","initialCursorPosition","cursorPosition","groupElement","groupRect","calculateDragOffsetPercentage","calculateDeltaPercentage","dir","layoutChanged","resizeHandleId","unsafePanelSize","prevCollapsedSize","prevCollapsible","nextCollapsedSize","nextCollapsible","nextMaxSize","nextMinSize","startDragging","stopDragging","flexDirection","Provider","PanelGroup","prevPanelData","PanelResizeHandle","disabled","onBlur","onDragging","onFocus","tabIndex","_hitAreaMargins$coars","_hitAreaMargins$fine","elementRef","callbacksRef","panelGroupContext","registerResizeHandleWithParentGroup","setState","isFocused","setIsFocused","resizeHandler","setResizeHandler","coarseHitAreaMargins","fineHitAreaMargins","_ownerDocumentCounts$","add","_ownerDocumentCounts$2","delete","focus","useWindowSplitterResizeHandlerBehavior","role","touchAction","userSelect","getPanelElement","getPanelElementsForGroup","getIntersectingRectangle"],"sourceRoot":""}